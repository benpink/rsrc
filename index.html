<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><title class="next-head">rsrc - simply fetching</title><meta name="viewport" content="initial-scale=1.0,user-scalable=no,maximum-scale=1,width=device-width" class="next-head"/><link rel="stylesheet" href="/static/styles.css" class="next-head"/><link rel="preload" href="/rsrc/_next/static/AsFMRfuFMlaE_o8yMNDWs/pages/index.js" as="script"/><link rel="preload" href="/rsrc/_next/static/AsFMRfuFMlaE_o8yMNDWs/pages/_app.js" as="script"/><link rel="preload" href="/rsrc/_next/static/AsFMRfuFMlaE_o8yMNDWs/pages/_error.js" as="script"/><link rel="preload" href="/rsrc/_next/static/runtime/webpack-42652fa8b82c329c0559.js" as="script"/><link rel="preload" href="/rsrc/_next/static/chunks/commons.d32c58893f404c7c451c.js" as="script"/><link rel="preload" href="/rsrc/_next/static/runtime/main-b9b53f3f44c8c7c1cf78.js" as="script"/></head><body><div id="__next"><header><nav><ul style="flex:3;justify-content:flex-start"><li class="logo"><a href="/rsrc/"><code>rsrc</code><small>Dead simple fetch management for React.</small></a></li></ul><ul style="flex:1;justify-content:flex-end"><li><a href="https://github.com/signalsciences/rsrc/"><img alt="Github" width="18" src="/static/github.svg"/></a></li></ul></nav><nav><ul><li><a href="/rsrc/guides/">Getting Started</a></li><li><a href="/rsrc/api/">API Reference</a></li><li><a href="/rsrc/demos/">Demos &amp; Playground</a></li></ul></nav></header><main><div class="content"><div><h1>rsrc</h1><p><strong>rsrc</strong> is a collection of components designed to help manage async fetch
operations in React.</p><h2>What problem are we solving?</h2><p>There are a number of great solutions for mananging async fetch state in the
React ecosystem but many of these patterns require a non-trivial amount of
boilerplate or framework knowledge to implement and maintain.</p><p>This project attempts to identify and abstract generic fetch state utilities into
composable components that are simple enough to reason about while remaining as
flexible and expressive as the underlying technologies they expose.</p><h3>Motivation</h3><ul><li>reduce dependence on common boilerplate for managing fetch state</li><li>encourage a declarative approach to resource operations </li><li>facilitate the collocation of resource descriptors with the components that
depend on them</li><li>simplify cache management and invalidation</li></ul><h2>What does this do?</h2><p>This library exports 3 components to manage and simplify async fetch operations
in React. </p><ol><li><strong>Cache</strong>. Cache is a context provider that exposes a simple
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">map</a>-like
interface. This should be mounted near the top of your application tree
similar to other context providers.</li><li><strong>Fetch</strong>. Fetch is a component that offers a declarative approach to the
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">fetch</a> api. Its
main jobs are to translate
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promise</a>
state into consumable props, provide a simple mechanism for caching and
expiring promises, as well as providing utilities to read, invalidate, and
refresh fetch states.</li><li><strong>Resource</strong>. Resource glues together the above functionality with a more
expressive interface. If Fetch represents an individual request state, a
Resource can be thought of as a generic entity description that defines and
exposes additional or related actions for a given endpoint.</li></ol><h2>What doesn&#x27;t this do?</h2><p>Currently, server side rendering (SSR), and cache initialization from serialized
state are not supported out of the box. rsrc leverages some unique
characteristics of promises to simplify state management internally.  Promises
are not serializable, which makes them less straight-forward to persist across
instances.</p><p>That said, the cache component accepts an arbitrary map-like interface, so it
should be possible to serialize resolved states, and then rewrap them in
promises before passing along to the cache provider.</p><p>For the time being though, we&#x27;ve chosen to optimize for ergonomics and simplicity over
persistance.</p><h2>References &amp; Credits</h2><p>Related projects, inspiration, and references:</p><ul><li><a href="https://github.com/heroku/react-refetch">heroku/react-refetch</a></li></ul></div></div></main><footer><div style="display:flex"><div style="flex:1;justify-content:flex-start">Â© 2019 Signal Sciences</div><div style="justify-content:flex-end"><a href="https://www.signalsciences.com"><img alt="Signal Sciences" width="120" src="/static/signalsciences.svg"/></a></div></div></footer></div><script>__NEXT_DATA__ = {"props":{"pageProps":{}},"page":"/","query":{},"buildId":"AsFMRfuFMlaE_o8yMNDWs","assetPrefix":"/rsrc","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/" src="/rsrc/_next/static/AsFMRfuFMlaE_o8yMNDWs/pages/index.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/rsrc/_next/static/AsFMRfuFMlaE_o8yMNDWs/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/rsrc/_next/static/AsFMRfuFMlaE_o8yMNDWs/pages/_error.js"></script><script src="/rsrc/_next/static/runtime/webpack-42652fa8b82c329c0559.js" async=""></script><script src="/rsrc/_next/static/chunks/commons.d32c58893f404c7c451c.js" async=""></script><script src="/rsrc/_next/static/runtime/main-b9b53f3f44c8c7c1cf78.js" async=""></script></body></html>